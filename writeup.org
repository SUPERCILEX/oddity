#+TITLE: Visualizing Distributed Systems
#+OPTIONS: toc:nil
#+LATEX_HEADER: \usepackage[margin=1.25in]{geometry}

* Abstract
This is a working document. We are developing a system for distributed
systems visualization, intended to be used primarily for pedagogical
purposes, both by lecturers in the classroom and by students
independently. We believe that such a system might also be useful to
practitioners who are designing distributed systems.

* Introduction
When I taught distributed systems with Tom last quarter, many of my
slides displayed handmade "animations" of a system in operation--e.g.,
node $A$ sends message $M$, node $B$ replies with message $N$, etc
(see figure). The course feedback we received indicated that students
found these slides quite useful: 
- "Lecture slides were amazing and really helped to visualize the
  different steps of an algorithm or system"
- "The diagrams in the slides were very helpful when it came to trying
  to understand the protocols"
Building these animations by hand, however, has a number of
drawbacks. It's tedious, error-prone, and most importantly
inflexible. If students have questions in class about scenarios not
covered by the animation--for instance, what happens if messages are
delivered in a slightly different order--the instructor is reduced to
verbal explanations and hand gestures.

We propose a system for automatically building animations of
distributed system execution. Users will write descriptions of
protocols and systems in a domain-specific language. The system will
take that description and generate a visual simulation of the
program's execution. The simulation can be left to run randomly, or
the user can control it manually (for instance, to decide when
messages are delivered). State at each node and the in-flight messages
are presented visually.

* Related work
** Runway
Runway is a system developed by Diego Ongaro (the author of Raft)
based on RaftScope, a raft-specific in-browser visualization. Runway
includes an interpreter for a simple simulation DSL (language
constructs include standard control flow and functions as well as
"rules" which modify global state and are used by the simulation
engine), and a system for building D3-based visualizations of system
executions. It has rudimentary support for defining system invariants
and for model checking (all collections in the language have bounded
size, so model checking is simple). There is no "default"
visualization for a distributed system (all visualizations are
system-specific) and the visualizations built so far do not seem to
lend themselves to recording particular execution sequences for
pedagogical purposes. We will likely build on Runway.
** TODO ShiViz

* Design goals

Let's take Paxos, as presented in "Paxos Made Moderately Complex," as
an example. We want instructors and students to (easily) be able to:
- See how acceptors respond to leaders with different ballot numbers
- See why Paxos isn't live without a consistent leader (leaders
  continually send `p1a` messages with higher ballot numbers)
- See why Paxos isn't safe if acceptors respond "OK" to p1a requests
  with lower ballot numbers

The first point requires instructors to be able to record particular
executions (and pieces of executions). The second requires users to be
able to control the order in which timeouts are fired and messages are
delivered. The third requires users to be able to modify the model
easily (in this case, to remove the check that the incoming ballot
number is higher than the previous one) and simulate an execution.
